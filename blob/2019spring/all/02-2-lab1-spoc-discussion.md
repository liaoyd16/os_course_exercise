# lec4: lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. x86段寄存器的字段含义和功能有哪些？

> x86段寄存器为16位，其中[15..3]为段索引index，[2]为TI（映射到LDT或GDT），[1..0]为优先级标号RPL

1. x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

> - DPL规定访问该段的权限级别，每个段的DPL固定；存储在段描述符中；
> - CPL是当前进程的权限级别，是当前正在执行的代码所在的段的特权级；存在于cs寄存器的低两位；
> - RPL说明的是进程对段访问的请求权限，表示以何种优先级访问代码段；存在于段选择子中。
>
> 
> - 一般要求DPL >= max {CPL, RPL}
> - CPL <= DPL(门)；CPL >= DPL(描述符)
> - RPL <= DPL(待访问的段)

1. 分析可执行文件格式elf的格式（无需回答）

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

> 压栈内容为EFLAGS，CS，EIP，ERROR-CODE；
>
> 内核态中出现中断，向内核栈压栈，并且恢复时只需弹出CS，EIP；恢复EFLAGS，ERROR-CODE；
>
> 用户栈中出现中断，切换到内核态；向内核栈压栈，除EFLAGS，CS，EIP，ERROR-CODE外，还需要压入SS，ESP，用于切换到正确的用户栈状态。

2. 为什么在用户态的中断响应要使用内核堆栈？

> 为了区别优先级、确保安全性。
>
> 由于用户程序可以随意更改栈指针，甚至更改为不合法的栈指针，因此内核必须要求一套由自己控制的栈指针。

3. x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

> int来自于硬件，进行异步处理，因此可以嵌套。但其处理方式是当中断处理完成后再处理下一个；如果在中断门不作区分，则会重复触发中断。
>
> trap来自于软件，同步处理，因此可以重复触发中断，进行递归处理。
>
> 如果不作区分，都允许重复触发中断，则硬件中断无法正确处理；若都不允许，则软件中断时，其余线程无法使用其他硬件的系统中断，导致UI非常低效。

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

> ```C
> static __noinline uint32_t
> read_eip(void) {
>     uint32_t eip;
>     asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
>     return eip;
> }
> 
> static inline uint32_t
> read_ebp(void) {
>     uint32_t ebp;
>     asm volatile ("movl %%ebp, %0" : "=r" (ebp));
>     return ebp;
> }
> ```
>
> ebp：若不内联，由于read_ebp本身就是函数，函数调用将修改ebp，返回这个read_ebp的ebp而非调用者的。
>
> eip：由于汇编中无法直接获取eip，需要利用call指令将eip压栈的特性。调用read_eip函数后，eip被压到栈上。因此必须要用函数调用

### 4.4 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

> 不是的；因为此时中断例程还没有被加载进来。

## 开放思考题

1. 在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
